## 插入排序
```
const a = [1, 3, 5, 1];
const sort = a => {
  for (let i = 1; i < a.length; i++)
    for (let j = i; j-- && a[j + 1] < a[j];) 
      [a[j + 1], a[j]] = [a[j], a[j + 1]]
  return a
}
```

## 快速排序
```
const a = [1, 2, 3, 5, 1]
const sort = (a, s = 0, e = a.length - 1) => {
  if (s >= e) return 
  let l = s, r = e
  while (l < r) {
    while (l < r && a[r] >= a[s]) r--
    while (l < r && a[l] <= a[s]) l++
    [a[l], a[r]] = [a[r], a[l]]
  }
  [a[l], a[s]] = [a[s], a[l]]
  sort(a, s, l - 1)
  sort(a, l + 1, e)
  return a
}
```

## 归并排序
```
const sort = (a, l = 0, r = a.length - 1) => {
  if (l === r) return 
  const m = l + r >>> 1, t = []
  sort(a, l, m)
  sort(a, m + 1, r)
  let p1 = l, p2 = m + 1, i = 0
  while (p1 <= m || p2 <= r) t[i++] = p2 > r || p1 <= m && a[p1] < a[p2] ? a[p1++] : a[p2++]
  for (i = 0; i < t.length; i++) a[l + i] = t[i]
  return a
}
```

## 冒泡排序
```
const sort = (a) => {
  for(let i = 0; i < a.length - 1; i++) 
    for (let j = 0; j < a.length - 1 - i; j++) 
      if (a[j] > a[j + 1])[a[j], a[j + 1]] = [a[j + 1], a[j]]
  return a
}
```